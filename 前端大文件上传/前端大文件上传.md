# 大文件上传

相关知识点：

![image-20230603121749025](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230603121749025.png)

![](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230603123647456.png)

> - 前端传递给后端的数据，不可能是files，前端通过formData传递二进制数据给后端（必须要传递给后端能够看懂的东西
> - 前端传递给后端的数据一般包括两种：1.二进制blob（通过formData传输）2.base64传输
> - 

学习情况

| 内容                                                         | 时长 |
| ------------------------------------------------------------ | ---- |
| 阅读文件上传的 相关内容并做笔记<br>[相关文档](https://juejin.cn/post/6844903968338870285)<br>[代码文档](https://juejin.cn/post/6844904046436843527#heading-25) | 4h   |
| 入手项目需求                                                 | 1.5h |
| 代码解读                                                     | 3.5h |
| 代码单纯啃，有点费时间，先补充一些基本知识点                 |      |
| [花果山大圣文档](https://juejin.cn/post/6844904055819468808#heading-3) |      |
| [前端大文件上传](https://juejin.cn/post/6844903860327186445) |      |

## 相关文档笔记

上传一个文件，需要做的：

- 要把 form 标签的`enctype`设置为`multipart/form-data`,同时`method`必须为`post`方法。

  - 补充知识点：

    > `multipart/form-data`表示什么:
    >
    > - multipart:单词本身有混合的意思，表示资源是由多种元素组成 的，form-data表示可以使用HTML Forms 和 POST 方法上传文件
    > - 指定传输数据为==二进制类型==（不对字符编码），比如图片，mp3，文件。==是将文件以二进制的形式上传==，可以实现多种类型的文件上传

​				multipart/form-data数据格式是什么样的：

![image-20230531114412768](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230531114412768.png)

文件上传消息体（消息体的封装）

![image-20230531115126620](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230531115126620.png)

![image-20230531115236377](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230531115236377.png)

- 消息体的解析（服务端）

  有成熟的第三方可以使用

  

### 上传文件进度条显示

补充xhr的相关知识点，因为有些忘记了

> xhr=const xhr = new XMLHttpRequest();---创建xhr对象
>
> xhr.open()----准备发送请求
>
> xhr.send()----正式发送请求
>
> xhr.onreadystatechange ()----处理服务端返回过来的响应数据
>
> xhr常用的事件：
>
> - load:请求完成时触发
> - abort：终止请求时触发
> - progress：服务器响应数据时周期性触发
>   - lengthComputable：布尔值，当前进度能不能被测量
>   - loaded：执行到现在完成的工作量
>   - total：总的工作量(需要在响应头中携带`Content-Length`字段，total 相当于是读取这个字段的信息)

-----------------

回归正题			

> 将xhr的progress方法绑定在xhr.upload上面，监听文件上传的进度

![image-20230601134611586](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230601134611586.png)

### 多文件上传+预览+取消

多文件上传我的疑惑：

- 执行顺序的问题，并发上传（还没有搞清楚每个文件progress的执行顺序，使用for循环:对，使用的就是for循环，获取上传的文件，然后进行相关的处理之后，获取文件信息列表）

- 怎么监听到每个文件的上传过程：使用for循环

  多文件上传一般使用的不是在标签中加上multip这个属性，一般是创建一个数组，只要一上传文件，就往里面添加

  ![image-20230603131717944](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230603131717944.png)

### 大文件上传--分片

作用：解决了大文件上传超时（超时：与tcp链接有关，tcp链接进行数据传输之前，需要经过三次握手建立连接）和服务器的限制（什么限制：允许上传文件的大小限制）

使用的方法：flie.slice()//类似于字符串的操作

分片逻辑

```js
//分片逻辑  像操作字符串一样
      
    var start=0,end=0;
    while (true) {
        end+=chunkSize;
        var blob = file.slice(start,end);
        start+=chunkSize;//更新start，从chunkSize开始计算
        
        if(!blob.size){//截取的数据为空 则结束
            //拆分结束
            break;
        }
        
        chunks.push(blob);//保存分段数据
    }

```

相关参数：

| 参数           | 含义                                              |
| -------------- | ------------------------------------------------- |
| chunkSize      | 分片大小（chunkSize=2*1024*1024*;//分片大小 2M*） |
| chunks（数组） | 保存分片数据                                      |
| chunkCount     | 分片个数                                          |
| token          | 时间戳（作用是啥）                                |
|                |                                                   |

相关知识点：

> tcp链接:客户端到服务器端的一个链接，有最大连接数，当资源没有被释放的时候，就会一直占用内存，可能会导致系统达到最大连接数，如果此时还有新的连接请求，则这些请求将失败，因为系统无法再为新的连接分配更多的资源。

## 使用websocket

1. 什么是webscoket

> 全双工通讯的协议
>
> http:客户端主动发起请求，服务端响应
>
> tcp：tcp连接的两端，双方在同一时间可以主动向对方发消息
>
> http1.1:基于tcp协议 同一时间，客户端和服务端只能有一方发送数据（半双工）
>
> 怎么建立ws连接：
>
> 在建立的时候会使用到http协议，然后会有一个特殊的请求头，将协议升级成ws协议
>
> 适用场景：
>
> 客户端和服务端需要频繁交互的场景，比如网页和小程序游戏，聊天室，以及协同办公

2.和http协议对比的优势在

> http协议：一种无连接，无状态，单向的通信协议
>
> ![image-20230618212204833](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230618212204833.png)
>
> 什么是轮询:轮询是一种在客户端和服务器之间进行数据通信的方式。它的基本原理是客户端定时向服务器发送请求，查询是否有新的数据可用。如果服务器有新的数据，就将其返回给客户端；如果没有，就返回空响应。客户端在接收到响应后，解析数据并执行相应的操作，然后再等待下一个周期继续发送请求。
>
> 轮询的主要缺点是效率低下，因为客户端需要频繁地发起请求，并且每次请求都需要建立和关闭连接，会产生较高的网络延迟和带宽消耗。此外，即使服务器没有新的数据可用，客户端也必须等待整个周期才能从服务器接收响应，这会浪费许多资源。
>
> WebSocket 的出现解决了轮询带来的这些问题，可以实现更加高效和实时的通信
>
> ![image-20230618212646725](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230618212646725.png)

1. 服务端主动将数据推送给客户端

## 上传文件需要考虑的问题

> 1. 文件切片上传由于是并发，传输到服务端的顺序可能会发生变化，需要给文件切片标上序号，也就是说，文件切片传递到服务端的顺序可能不是按照传递之前的顺序
> 2. 

### 遇到的问题

==文件很大，分片过多，导致并发过多，tcp链接被占光，需要做并发控制==

步骤：

- 把大文件进行分段 比如2M，发送到服务器携带一个标志，暂时用当前的时间戳，用于标识一个完整的文件
- 服务端保存各段文件
- 浏览器端所有分片上传完成，发送给服务端一个合并文件的请求
- 服务端根据文件标识、类型、各分片顺序进行文件合并
- 删除分片文件

前端干的活：

- 对文件进行分片，之后获得一个数组
- 发送分片前：需要给分片加上一个token（时间戳）以及index（索引）
- 当全部发送完成之后，需要通知服务器合并所有文件（这个函数作为发送请求的回调函数，这里好巧妙啊）

### 大文件上传---断点续传

> 大文件上传并不是短时间内就上传完成，如果期间断网，页面刷新了仍然需要重头上传,这种时间的浪费怎么能忍？

断点续传：实现断点续传，已上传的部分跳过，只传未上传的部分

重点问题：如何区分哪些文件已经上传成功了

方法一：==可以在本地进行保存已上传成功的分片，==

==重新上传的时候使用`spark-md5`来生成文件 hash，区分此文件是否已上传。==

用自己的理解：在文件上传过程中，已经上传成功的会保存在本地，并且每个分段都会有hash值，当上传过程突然断开，重新上传的时候，每个分片的也都有自己的hash值（特别注意，每个分片的hash值是固定，根据文件内容生成的），把分片与本地的进行对比，如果是相同的，就证明之前已经上传过了，直接跳过。

步骤：

> - 为每个分段生成 hash 值，使用 `spark-md5` 库（这里每个分段指的是所有分片吗）
> - 将上传成功的分段信息保存到本地
> - 重新上传时，进行和本地分段 hash 值的对比，如果相同的话则跳过，继续下一个分段的上传

方法二：从服务端获取已经上传的分片信息（因为分片保存在本地不是很有保障）

--------------------------

看完了新手需知之后，需要做的就是手写代码，了解里面运用了什么原理

断点续传更深的了解

断点，也就是取消上传的意思，怎么取消上传，涉及到xhr对象中的abort方法，需要将文件切片的xhr对象保存起来（这里会创建一个数组，将正在上传的文件切片保存起来，如果要取消上传，直接调用xhr.abort方法就可以了）

续传，已经上传成功的切片保存在服务器中，只需要请求一下接口，返回之前已经上传过的切片数组，在上传的时候，过滤掉这些切片就可以了

==断点续传涉及到进度条倒退的问题==

解决的办法就是创建一个假的进度条，这个进度条只增加或暂停，但是不会倒退



## 项目需求

> - 背景：
>
>   当今 web 应用功能强大，偶尔可能出现需要通过 web 页面上传上百 G 文件场景(例如人工智能服务中的训练与模型数据)，文件越大，必然上传时间越长，这可能导致几个问题：
>   上传过程一旦出现网络波动，前功尽弃，需要重新开始；
>   上传过程容易出现服务端过载、浏览器内存溢出等问题，失败可能性极高；
>   上传时间较长，可能影响用户体验。
>   为此，通常需要为大文件上传场景设计一套较通用的分片上传机制，确保系统健壮性。
>
> - 基本方案
>
>   当今 web 应用功能强大，偶尔可能出现需要通过 web 页面上传上百 G 文件场景(例如人工智能服务中的训练与模型数据)，文件越大，必然上传时间越长，这可能导致几个问题：
>   上传过程一旦出现网络波动，前功尽弃，需要重新开始；
>   上传过程容易出现服务端过载、浏览器内存溢出等问题，失败可能性极高；
>   上传时间较长，可能影响用户体验。
>   为此，通常需要为大文件上传场景设计一套较通用的分片上传机制，确保系统健壮性。
>
> - 具体方案
>
>   主流程：
>   浏览器端选定文件后，首先计算整个文件 md5 值，并发送到服务端，由服务端判定该文件是否已经存在，若已存在则直接跳过后续步骤，实现文件秒传
>   在浏览器端使用 file.prototype.slice 切割文件，切割后：
>   按顺序记录索引与切片 md5 值（index,md5值）√
>   发送 索引与 切片 md5 值到服务端√
>   将切片索引、md5、切片内容一并存储到 indexdb，方便实现页面刷新后重新上传（<font color='red'>这个没做过，不熟悉</font>)
>
>   ![image-20230619171424853](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230619171424853.png)服务端记录任务信息
>   浏览器端开始上传切片，分两步：
>   首先尝试发送 md5，服务端判断该切片是否已经存在（==发送请求，由服务端来判断==），若存在则跳过上传过程，实现分片秒传
>   发送分片内容
>   上传过程实时展示上传进度，支持用户取消上传（<font color='green'>熟悉，上面有看过</font>)
>
>   加分：
>   有没有可能使用 websocket 进一步提速？
>   上传之前可否使用 jszip 压缩内容？
>   如何实现暂停、取消？
>
> - 产物
>
>   输出完整、可运行代码(github) + 线上演示地址
>   输出项目总结，内容：
>   使用了什么技术
>   系统关键设计说明
>   关键流程图
>   过程中遇到什么问题(这个非常关键)

### 知识点

- 什么是md5值

  > md5是一种哈希算法，可以将数据或文件生成固定长度的唯一字符串，md5值可以对文件的完整性提供保障和验证，只要文件 发生损坏或者修改，md5值就会发生改变

- 什么是indexdb

  > 浏览器内置的客户端数据库，可以让 web 应用程序在浏览器中存储和操作大量的结构化数据，而不需要向服务器发送请求，可以通过js进行访问和操作。
  >
  > 它提供了强大的数据检索和索引功能，并保证数据在各个浏览器会话间的持久性和稳定（没懂最后这句话什么意思）

## 代码编写

1. 文件分片（**createFileChunk**）
2. 计算分片的md5值，发送到服务端（md5值+索引）（**calculateHash**）
3. 上传文件，这里会返回shouldUpload, uploadedList（之前上传过的分片），如果shouldUploa是fasle，表示之前已经上传过了，直接跳过后面步骤
4. 上传切片，首先需要过滤掉已经上传过的切片，构建一个formData,里面是要传递给后端的东西，之前再将每一个分片上传，如果所有的分片都上传成功了，就向服务端发起请求，合并文件
5. 如果所有分片上传完成，需要向服务端发送一个请求，要求服务端合并文件

- 计算整个文件 md5 值，并发送到服务端，由服务端判定该文件是否已经存在，若已存在则直接跳过后续步骤，实现文件秒传

  

代码中运用到的方法：

| 方法                      | 作用                                                         |
| ------------------------- | ------------------------------------------------------------ |
| **request**               | 请求后端                                                     |
| **handleFileChange**      | 将选择的文件放进数据里面                                     |
| **createFileChunk**       | 生成文件切片                                                 |
| **calculateHash**         | 生成整个文件的hash                                           |
| **handleUpload**          | 上传文件                                                     |
| **verifyUpload**          | 判断这个文件之前是不是已经上传过了，没有才会继续上传分片     |
| **uploadChunks**          | 上传分片                                                     |
| **mergeRequest**          | 通知服务器合并分片                                           |
| **createProgressHandler** | 计算上传进度                                                 |
| **handleResume**          | 继续上传文件                                                 |
| **resetData**             | 将数据清空                                                   |
| **handlePause**           | 文件上传的过程停止上传                                       |
| **handleDelete**          | 后端会删除已经上传的文件，就是在服务器没有这个文件的上传记录了 |

特别注意：这里不是每个分片都生成hash，每个分片的hash是整个文件的hash+index（index来区分分片的hash）

相关网络知识:

- http的可并发性：当一个客户端发起多个请求到服务器时，服务器可以同时处理这些请求而不是等待一个请求的响应完成后才能处理下一个请求。

  > 借助 http 的可并发性，同时上传多个切片。这样从原本传一个大文件，变成了`并发`传多个小的文件切片，可以大大减少上传时间
  >
  > 并发需要考虑的点：
  >
  > ==由于是并发，传输到服务端的顺序可能会发生变化，因此我们还需要给每个切片记录顺序（index）==

- 生成切片的hash

  > 如果上传的文件过大，读取文件内容非常耗时，可能会引起ui阻塞，可以有两种方法：
  >
  > 1. 需要开启另外一个线程来计算hash，使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互
  > 2. 可以参考`React`的`FFiber`架构，通过`requestIdleCallback`来利用浏览器的空闲时间计算，也不会卡死主线程（requestIdleCallback会传入一个回调函数，在浏览器空闲的时候就会执行（这是优先级比较低的任务，如果中途有优先级高的任务，这个任务就会中断））

性能优化：

- 开启另外一个线程计算hash（web-worker ）
- 控制并发数

### 文件分片

```js
 /***
     * file:文件
     * size：每一段切片的大小
     */
    createFileChunks(file,size=SIZE){
      //定义一个数组存储切片，以对象的形式存入
      let fileChunkList=[];
      let cur=0;
      if(cur<file.size){
        fileChunkList.push(file.slice(cur,cue+size));
      cur+=size;
      }
     return fileChunkList;
    },
```



# 问题集结

观看文档：

https://juejin.cn/post/6844903968338870285

![image-20230531232902313](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230531232902313.png)		代码解读1：

![image-20230601134355142](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230601134355142.png)

代码解读2：

![image-20230603115440996](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230603115440996.png)

![image-20230603115446841](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230603115446841.png)

![image-20230603115457558](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230603115457558.png)

requetList里面的数据结构是什么样的

代码解读3：

![image-20230603133145177](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230603133145177.png)

代码解读4：

![](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230603191843647.png)

需要解决的问题：

![image-20230618203541771](C:\Users\马镇涛\AppData\Roaming\Typora\typora-user-images\image-20230618203541771.png)

- ~~进度条倒退的问题~~
- ~~如果文件过大，切片数过多，过多的`HTTP`链接过去，也会把浏览器打挂，可以通过控制异步请求的并发数来解决（头条面试题）,这个必须会~~
- 由于文件大小不一，我们每个切片的大小设置成固定的也有点略显笨拙，我们可以参考==`TCP`协议的`慢启动`策略==， 设置一个初始大小，根据上传任务完成的时候，来动态调整下一个切片的大小， 确保文件切片的大小和当前网速匹配（怎么动态调整）
- ~~需要做切片上传失败的处理~~
- 使用 websocket 由服务端发送进度信息

- 打开页面没有自动获取上传切片，而需要主动再次上传一次后才显示

对于已有的代码需要进行改进的

- [x] 请求的并发控制

- [x] 并发上传过程中，报错怎么重试，比如每个切片我们允许重试两次，三次再终止

- [x] 设置进度条方块

- [ ] 文件碎片清理

- [ ] 文件切片的大小不限制死，和当前的网速匹配

- [ ] 使用websocket由服务端发送进度信息（服务端主动向客户端发送信息）

- [ ] 打开页面没有自动获取上传切片，而需要主动再次上传一次后才显示

- [ ] 上传过程中页面刷新了，应该怎么做

  

file-upload代码 需要改进的点：

- 请求的并发控制：设置一个数，当正在请求，占用通道，请求成功，释放通道，当通道数量使用完，就不能上传，当一个请求完成之后（通道有一个位置是空闲的），就再发送一条请求
- 请求的并发控制，报错重试：请求失败，释放通道，数组统计，当失败数量超过限制，就直接返回一个promise，没有超过限制，就递归，继续上传
- 文件碎片清理：定期将target文件下面的切片清理干净（怎么做呢）